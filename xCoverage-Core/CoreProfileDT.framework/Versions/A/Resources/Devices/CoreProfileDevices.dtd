<?xml version="1.0" encoding="UTF-8"?>


<!-- For the moment there is no intrinsic way to extend/refine/whatever other device descriptions.  In particularly, the typical scenario is to have a public version of the description and a private, which simply adds additional registers, fields, etc to the public version.  For now the approach being encouraged is to use XIncludes, which provides very high flexibility and can always be sidetracked in future if it makes sense to introduce more intrinsic methods for doing the same things.  In terms of implementation, additionally, we may reserve the option of optimising specific cases where it makes sense (I'm particularly thinking about the fact that we don't want to be duplicating strings in memory).

	XPointer examples:
	
	Include the register with mnemonic 'PIR' from any of the address spaces of a particular device:
		<xi:include href="970.xml" xpointer="xpointer(/*/device[@name='PowerPC 970']/addressSpace[*]/register[@mnemonic='PIR'])" />
	
	Include every register in all address spaces in a given device:
		<xi:include href="970.xml" xpointer="xpointer(/*/device[@name='PowerPC 970']/addressSpace[*]/register[*])" />
	
	Include every register in all address spaces in a given device, *except* those with the mnemonic 'VRSAVE':
		<xi:include href="970.xml" xpointer="xpointer(/*/device[@name='PowerPC 970']/addressSpace[*]/register[@mnemonic!='VRSAVE'])" />
	
	Include the registers with mnemonics 'SCOMC' or 'SCOMD' from any of the address spaces of a particular device:
		<xi:include href="970.xml" xpointer="xpointer(/*/device[@name='PowerPC 970']/addressSpace[*]/register[@mnemonic='SCOMC' or @mnemonic='SCOMD'])" />
  -->


<!-- Selecting Address Spaces

	Devices contain some number of address space references.  Each address space reference can (optionally) specify 'match' attributes which determine which address spaces are selected for use.  These match attributes are attributes in the special namespace "urn:CoreProfile:deviceMatching", which by default is aliased as "match".  So to match a 'logicalCore' attribute, for example, you would write 'match:logicalCore="blah"'.
	
	When instantiating devices, the framework will create an instance for every unique, valid permutation of address spaces, based on the restrictions in the XML and the list of available address spaces at any given time.  Match attributes can ultimately have one of three values:
	
		'*' - Wildcard, meaning match any.  This is the assumed value if the attribute is not specified.
		<value> - A value, whether a string or number or whatever is appropriate depending on the particular attribute.  Strings are treated as case insensitive.
		"$variable" - The name of a variable (case-sensitive).  When matching occurs, all same-named variables must match for a given permutation to be valid and result in an instance.  Variables name may technically be used across all types of address spaces and attributes, but the implementation reserves the right to barf in situations which don't really make sense (e.g. using the same variable to match both a IOClass and a PCI function number).
	
	Address spaces which do not have a given attribute will not match.
	
	Examples:
	
		<addressSpace match:IOClass="foo-bar-sod-woot">
			Selects the address space(s) of the given class.  One instance of the device will be created for every address space with the given class.
		<addressSpace match:IOClass="foo-bar-sod-woot" match:AppleRawSPRAddressSpaceLogicalCore="*">
			Similar to the previous example, but subtly different - this will match for any logical core, but this implicitly assumes that the address space has a 'AppleRawSPRAddressSpaceLogicalCore' attribute, unlike the previous example.  So any address spaces which don't will not match.
		<addressSpace match:IOClass="foo-bar-sod-woot" match:AppleRawSPRAddressSpaceLogicalCore="3">
			Matches any address spaces of the given class, but only those associated with logical core 3.
		
		<addressSpace match:IOClass="foo-bar" match:AppleRawSPRAddressSpaceLogicalCore="$index">
			Ultimately has the same effect as using a wildcard, since there is only one map defined and so every permutation will be valid.
		<addressSpace match:IOClass="foo-bar" match:AppleRawSPRAddressSpaceLogicalCore="$index">
		<addressSpace match:IOClass="troz-zort"  match:AppleRawSPRAddressSpaceLogicalCore="$index">
			A much more interesting example.  This will match all pairs of the given two types of address space that have the same logical core.  Additionally, since both address spaces are implicitly required (they don't specify otherwise), if say 'foo-bar' exists with logical core 2, but 'troz-zort' doesn't exist with logical core 2, then no device will be instantiated for that instance of 'foo-bar'.
		
		<addressSpace match:IOClass="AppleRawPCIAddressSpace" match:AppleRawPCIAddressSpaceVendorId="0x8086" match:AppleRawPCIAddressSpaceDeviceId="0x1963" match:AppleRawPCIAddressSpaceBusNumber="$bus" match:AppleRawPCIAddressSpaceSegmentNumber="$segment">
		<addressSpace match:IOClass="AppleRawPCIAddressSpace" match:AppleRawPCIAddressSpaceVendorId="0x8086" match:AppleRawPCIAddressSpaceDeviceId="0x3822" match:AppleRawPCIAddressSpaceBusNumber="$bus" match:AppleRawPCIAddressSpaceSegmentNumber="$segment">
		<addressSpace match:IOClass="AppleRawPCIAddressSpace" match:AppleRawPCIAddressSpaceVendorId="0x8086" match:AppleRawPCIAddressSpaceDeviceId="0xd820" match:AppleRawPCIAddressSpaceBusNumber="$bus" match:AppleRawPCIAddressSpaceSegmentNumber="$segment">
		<addressSpace match:IOClass="AppleRawPCIAddressSpace" match:AppleRawPCIAddressSpaceVendorId="0x8086" match:AppleRawPCIAddressSpaceDeviceId="0x8ffc" match:AppleRawPCIAddressSpaceBusNumber="$bus" match:AppleRawPCIAddressSpaceSegmentNumber="$segment">
			A more complex example but along the same lines - this essentially matches groups of PCI address spaces that have the given vendor & device IDs, and also share the same PCI bus and segments.  So if you had the same address spaces on two buses, you'd get two instances of the device, one for each bus. -->


<!ENTITY % Metainfo "copyright | confidential | author | creationDate | revisions">
<!ENTITY % BooleanNames "1 | 0 | on | off | true | false | yes | no | high | low">


<!-- Document root -->
<!ELEMENT CoreProfileDevices (device | %Metainfo;)*>
<!ATTLIST CoreProfileDevices
	xmlns:xi CDATA "http://www.w3.org/2001/XInclude">


<!-- Author & File information -->
<!ELEMENT copyright (#PCDATA)*> <!-- A human-readable string stating the copyright of the entire file.  No 'default' is defined if this is absent, so for now ensure this is here and err on the side of restriction for the sake of safety.  There should only be at most one per file. -->
<!ELEMENT confidential (#PCDATA)*> <!-- A confidentionality statement.  Slightly distinct from copyright, this is typically something like "Restricted to the L78/B group, do not distribute".  The intention is to display this prominently if present.  There should only be at most one per file. -->
<!ELEMENT author EMPTY> <!-- An author of the file.  May be any number. -->
<!ATTLIST author
	name CDATA #REQUIRED
	email CDATA #IMPLIED
	phone CDATA #IMPLIED
	organization CDATA #IMPLIED> <!-- 'name' is the author's full name, which may be that of a group or division as appropriate if individual attribution is undesired.  In such cases 'organization' should still be provided, even if redundant. -->

<!ELEMENT creationDate (#PCDATA)*> <!-- Dates are ISO formatted, i.e. "YYYY-MM-DDThh:mm:ss[Z|±hh:mm]" (where fields may be missing starting from the rightmost, and the '-' and ':' separators are optional).  A suffix of 'Z' indicates GMT timezone, while a suffix of either -hh:mm or +hh:mm indicates an offset from GMT.  If a time zone is not specified, the local time zone is assumed. -->

<!ELEMENT revisions (revision)+>

<!ELEMENT revision (#PCDATA)*> <!-- Notes revision information about a file.  This is primarily for curiosity and bookkeeping purposes at this point, but in future may be used in various ways, such as automatically determining the differences between two given copies of a file, based on their revision info, and using that in the UI to inform the user what a given update is about, etc. -->
<!ATTLIST revision
	version CDATA #REQUIRED
	date CDATA #REQUIRED> <!-- Dates are ISO formatted, i.e. "YYYY-MM-DDThh:mm:ss[Z|±hh:mm]" (where fields may be missing starting from the rightmost, and the '-' and ':' separators are optional).  A suffix of 'Z' indicates GMT timezone, while a suffix of either -hh:mm or +hh:mm indicates an offset from GMT.  If a time zone is not specified, the local time zone is assumed.
	
		'version' is a string of standard "x.y.z[abdf]N" format, or a portion thereof - e.g. "1.0", "1.3.2", "1.2b3", "23.2.182d2834", etc.  Revisions will be sorted by this string appropriately, so their order of appearance does not matter though by convention is to have the latest at the top. -->


<!-- Devices -->
<!ELEMENT device (summary?, description?, (addressSpace | pmc | event)*)> <!-- A logical device, e.g. a GPU (or GPU core, depending on granularity exposed by the hardware), a CPU core, a discrete memory controller, etc. -->
<!ATTLIST device
	class CDATA #REQUIRED
	name CDATA #REQUIRED
	supersedes CDATA #IMPLIED> <!-- 'class' is the class of device.  May be anything, but certain classes are recognised and mapped to purposed subclasses in the framework (e.g. "logical-processor-core", "pci-device", etc).  At the moment these are not well defined, so simply using whatever class name seems most appropriate and we can normalise these at a later date.  We may at one point allow specification of class hierarchies here, and create actual subclasses dynamically at runtime, but there's no support for this today (though to allow for this both the ':' and ',' characters are not permitted in class names).
	
		'name' is the human-readable name for the device, which is largely up to the definer to purpose, but is typically things like e.g. "MacPro1,1" for a 'system' device, or 'Intel Xeon 5100', or 'ATI Radeon™ HD 2600XT" or whatever.
		
		FWIW, leading and trailing whitespace in the 'name' and 'class' attributes will be ignored.  Neither 'class' nor 'name' may contain colons or commas.  'supersedes' contains a comma-separated list (with whitespace around the comma permitted) of one or more device names to replace with the new device.  Typically you use this to supersede a lesser definition of a given device, e.g. if you have a private XML file that includes additional registers and whatnot over the public one, you would in the private definition supersede the public one.  This will prevent both appearing from the framework (since otherwise, to the framework, they both exist, they just happen to share some sprmaps or memorymap or whatever). -->


<!-- Address Spaces -->
<!ELEMENT addressSpace (summary?, description?, (register | capability)*)> <!-- An address space.  May contain registers and/or PCI capability groups. -->
<!ATTLIST addressSpace
	xmlns:match CDATA "urn:CoreProfile:deviceMatching"
	baseAddress CDATA "0"
	required (%BooleanNames;) "yes"> <!--
		'baseAddress' is the base offset within the address space from which all the register offsets are themselves offset.  Most useful, typically, for memorymap address spaces where it would be the address of the start of the relevant memory-mapped range.  It may also be the mnemonic of a register or register field containing the offset, e.g. 'MSR_PMU_MAPADDR' or 'MSR_MAPADDRS[PMU]' respectively.  Only registers within the same device are considered, and only one may match the mnemonic(s) specified (as a rule register mnemonics should be unique within a device, and field mnemonics should be unique within their register).
				
		'required' is whether or not this address space must be present for the device using it to be considered as existing.  By default all maps are assumed as being required. -->

<!ELEMENT capability (summary?, description?, register*)> <!-- A PCI config space capability. -->
<!ATTLIST capability
	id CDATA #REQUIRED
	type (pci | pcie) #REQUIRED
	name CDATA #IMPLIED> <!-- 'id' is the capability number (as a hex/decimal/oct/binary number).
	
		'type' is the PCI capability type, either "pci" (for PCI 3.0 capabilities) or "pcie" (for PCIe 1.1 extended capabilities).
		
		'name' is a human-readable name for the capability, as might be shown in a summary list of capabilities for a given PCI device or somesuch. -->


<!-- Registers -->
<!ELEMENT register (summary?, description?, field*)> <!-- Represents a logical register.  For most maps these are very literal descriptions of raw bits somewhere in some memory.  They can hypothetically be somewhat abstract, since ultimately there's a kext that liaisons on them all, but we're really trying to stick to describing the real hardware at this layer, so aside from the kext knowing exactly how to correctly read/write the values, we don't want to imbue it with any further knowledge. -->
<!ATTLIST register
	name CDATA #IMPLIED
	mnemonic CDATA #IMPLIED
	offset CDATA #REQUIRED
	bitWidth CDATA #REQUIRED
	defaultAccess CDATA #REQUIRED
	existsIf CDATA #IMPLIED
	endianness (big | little | host) "host"> <!-- 'name' is the human-readable name of the register.  'mnemonic' is a human-readable mnemonic, that may not contain whitespace.
	
		'offset' is the offset within the address space at which this register lives.
		
		'bitWidth' is the width in bits of the register.  Must be 1 or greater.  Registers larger than 64 bits can certainly be defined, though the framework will not necessarily handle them well at this time.  You could technically divide them up into pieces that are smaller, but we'd really rather know when and where this is an issue and fix the framework.
		
		'defaultAccess' is the default access for fields in this register - see the access policy coding information below.
		
		'existsIf' is a conditional expression defining when this register exists.
	
		'endianness' specifies the native hardware endianness of the register.  This determines how the physical bits are numbered; e.g. in a 64-bit register bit 0 in little-endian is bit 63 in big-endian.  Thus, changing this will require you to change your bit numbers (if you wish to refer to the exact same bits as before).  Note that this is distinct from the 'endianness' property of the individual fields, which determines how they are then interpretted (so you could have a big-endian number field inside a little-endian register, if you like).  Also note that by specifying 'host' you'll have the endianness chosen at runtime (useful for certain PCI devices which adapt automatically, for example). -->


<!-- Access policy coding:
	
	Note that the modes specified below are literal modes, not symbolic of privilege level.  So while on PPC it looks the same, with user, supervisor and hypervisor modes, these represent actual hardware states and don't necessarily map to how a particular OS will partition things up.  To reiterate, these XML descriptions are intended to describe the hardware itself, regardless of how the software running on it partitions itself between privilege modes or rings or whatever.
	
	For now we recommend writing the ring number in the XML, (e.g. "0=rw,123=r"), as documented below, and we'll figure out exactly how the framework will translate these to logical privilege levels (i.e. userspace or kernel space) later on... ideally the framework won't need OS-specific versions, but then given it will need to be recompiled for new architectures anyway...
	
	Note that some registers or fields change access policy at runtime.  On Intel these are known as 'lockable' bits.  Such registers/fields should be marked with the 'i' flag ("inconsistent") to signify this, and the permissions given made to reflect those that are the most relaxed *without* being dangerous.  e.g. if the permissions change such that a rw field becomes only readable, but that subsequent writes will just fail silently or throw a software-handlable trap, then go with "rw" as the general permissions.  If on the other hand writes would cause a hardware fault or otherwise likely kill the system, go with "r" by default.  End users will ultimately always be able to override what the framework indicates (at least to the limits that the kexts, if applicable, allow), but it's nicer to err on the side of caution by default, as that'll prevent the framework blissfully doing the wrong thing.
	
		Modes:
			PPC:
				h - Hypervisor.
				s - Supervisor.
				u - User.
			Intel:
				0, 1, 2, 3 - Intel rings.
				h - Hypervisor mode (perhaps; needs review as to how this would work exactly).
		
		Global flags (not linked to specific modes):
		
			p - Persistent (preserved across power cycles).
		
		The following apply within the scope of a particular mode or modes:
		
			r - Readable.
			R - Readable, read has side-effects (i.e. don't read casually - I'm looking at you, Reggie - and also don't assume values of other fields within the register, or any other for that matter, will be unaffected by the read).
			
			Additional read options:
				c - Read returns existing value, then clears.
				C - Read clears and returns 0.
				s - Read returns existing value, then sets.
				S - Read sets and returns 1.
				t - Read returns existing value, then toggles.
				T - Read toggles and returns the new value.
			
			w - Writable.
			W - Writable, write has side-effects (i.e. writing may change values in other fields, or in other registers).
			
			Additional write options:
				c - Write of 0 clears (default; implicit if not specified).
				s - Write of 0 sets.
				t - Write of 0 toggles.
				n - Write of 0 doesn't change value.

				C - Write of 1 clears.
				S - Write of 1 sets (default; implicit if not specified).
				T - Write of 1 toggles.
				N - Write of 1 doesn't change value.
				
				o - Write can only be performed once.
			
			i - Inconsistent (access policy may change at runtime).

		
		e.g.:   h=rw,s=rw,u=r		Privileged write, all can read.
				hs=rw,u=r			(shorthand for the above)
				
				h=rwcC,s=rwcC,u=r	Privileged write (which clears), all can read.
				hs=rwcC,u=r			(shorthand for the above)
				
				h=R,s=R				Privileged read (which has side-effects).
				hs=R				(shorthand for the above)
				
				hsu=rC				Readable by all, always returns 0.
				rC					(shorthand for the above)
				
				ph=rWcC,s=r			Hypervisor can read and write (which clears and has side-effects, supervisor can read).  Value is persistent.
		
		e.g. Intel's permission categories:
		
				ReadOnly			r
				WriteOnly			w
				ReadWrite			rw
				ReadWriteHighClear	rwnC
				ReadWriteOnce		rwo
				ReadWriteLock		rwi
				ReadWriteAnyClear	rwC
				ReadWriteLowClear	rwN
				Sticky				p

		For the moment use of relative permissions (e.g. '+' and '-' modifiers) is not supported, on the grounds that it's largely unnecessary and adds complexity (for humans) when interpreting the files.
	-->


<!-- Fields -->
<!ELEMENT field (summary?, description?, (settings | bit | setting | on | off)*)> <!-- A field within a register. -->
<!ATTLIST field
	name CDATA #IMPLIED
	mnemonic CDATA #IMPLIED
	type (reserved | bitfield | switch | status | enum | number) #IMPLIED
	bits CDATA #REQUIRED
	base CDATA #IMPLIED
	signed (%BooleanNames;) #IMPLIED
	access CDATA #IMPLIED
	defaultValue CDATA #IMPLIED
	displayFunction CDATA #IMPLIED
	units CDATA #IMPLIED
	existsIf CDATA #IMPLIED
	endianness (big | little | host) #IMPLIED> <!-- 'name' is the (ostensibly) human-readable name of the field.  It is optional.
	
		'mnemonic' is the (ostensibly) human-readable mnemonic for the field.  It may not contain whitespace.
		
		'type' is the field type.  This is entirely optional but conveys to higher layers the general semantics of the field, which may aid in how that field is displayed and edited.  The default, if not specified, is undefined and left up to the end developers.
		
		'bits' defines the bit or bits that make up the field, in the form "X" or "X:Y".  These bit designations take into account the endianness of the register itself as defined, so keep in mind that bit 0 in little-endian mode is bit N-1 (where N is register bitwidth) in big endian mode.  This attribute is *not* influenced by the 'endianness' attribute on the field itself (that is one layer below).
		
		'base' is the numeric base of the field.  Again, entirely optional, but potentially useful to higher layers for determining how best to display the value.  May be specified for any type of field (since users may explicitly choose to view any field in any way, so having an appropriate 'base' specified, even if the field is really of a more specific type, can still be helpful).  The default is undefined, if not specified, and left up to the end developers.
		
		'signed' indicates whether the field should be interpreted, when done so as a number, as signed or unsigned.  If undefined the default behaviour is left up to the end developers (e.g. they may display both, or just assume one or the other).
		
		'access' is the access policy of the individual field.  If not specified the default access policy (as specified by the 'defaultAccess' attribute of the parent field) is used.
		
		'defaultValue' is the default value of the field when the hardware first starts up.  If there is no defined default, do not specify this attribute.
		
		'displayFunction' is an expression to use for formatting the value for display.  e.g. "(($ * 3.75) - 39.25)" where '$' is substituted for the value in question.  The expression must be reversible.  Again, entirely optional, but may be useful if a field represents a common unit or metric, but has an odd multiplier or offset in the actual hardware.  Whether or not this field is used is left up to the end developer.
		
		'units' specifies the units of the field.  Again, optional and entirely up to the end developer to make use of, though this may be useful not just for presentation but also for facilitating automatic unit conversion (e.g. if the units are specified as "°C" the end app might recognise this and convert to Fahrenheit if the end-user prefers).
		
		'existsIf' is a conditional expression defining when this field exists.
		
		'endianness' specifies the endianness in the field itself.  Most useful for numeric fields, but generally applied when reading the value as anything but raw data.  If not specified it is taken as being the same as the containing register (which itself defaults to 'host' if not otherwise defined). -->


<!ELEMENT settings (summary?, description?, (bit | setting | on | off)*)> <!-- A 'setting' is a defined logical value for a field.  The 'settings' construct allows grouping of settings with a conditional indicating when that settings group applies. -->
<!ATTLIST settings
	applyIf CDATA #IMPLIED> <!-- 'applyIf' is a conditional indicating when the settings contained in the group apply. -->

<!-- Field values -->
<!ELEMENT bit (#PCDATA)*> <!-- Identifies a particular bit within a field.  These 'bits' are distinct from settings, in that they are by nature orthogonal - the meaning of one bit is irrelevant to the meaning of others.  This is most useful for bitfields where they are logically one single field, but each bit is somewhat independent.  e.g. VRSAVE on PPC, which is clearly a bitmask, but where you still want to name each bit individually so it's clear which VR register each bit applies to.  Note that you can specify both 'bits' and 'settings' for the one field; they are independent. -->
<!ATTLIST bit
	index CDATA #REQUIRED
	name CDATA #REQUIRED
	recommendedState (1 | 0) #IMPLIED> <!-- 'index' is the bit index (taking into account the endianness of the field).
	
		'name' is the human-readable name of the bit.
		
		'recommendedState' is the manufacturer-recommended setting, if any, for the bit.  Use this only if there is a clear and fairly unanimous reason for the recommendation - e.g. the machine runs 1000x slower with the wrong setting, or the wrong setting may cause the machine to hang and isn't generally useful anyway, etc.  This recommendation may (but may not) be conveyed to end users - it is left up to the end developers to use if they choose. -->

<!ELEMENT setting (#PCDATA)*> <!-- 'setting' describes one logical setting for a field.  A setting may represent multiple literal values, if there is redundancy within the fields' settings space.  Note that you can specify both 'bit's and 'setting's for the one field; they are independent. -->
<!ATTLIST setting
	name CDATA #IMPLIED
	value CDATA #REQUIRED
	mnemonic CDATA #IMPLIED
	recommended (%BooleanNames;) #IMPLIED> <!-- 'name' is the human-readable name of the setting. 'mnemonic' is the human-readable mnemonic for the setting.  The latter may not contain whitespace.  At least one of the two, if not both, must be specified.
	
		'value' should follow the general expression ((number | range) (',' (number | range))*).  e.g. "7", "8-9", "3,5,10", "0x00-0x3f,0x60-0x7f,0x90,0xa0", etc.  Numbers may be in hex, decimal, octal or binary format.  Ostensibly the values may also be specified as data (using the '@' prefix followed by the hex form of the data) or as strings (by enclosing them in single or double-quotes), though at time of writing the framework really doesn't handle these very well (though they most likely will be, given the registers of some more exotic devices truly do contain strings or binary data).
		
		'recommended' indicates whether the setting is particularly recommended or particularly *not* recommended.  If not specified no recommendation is implied, which is usually what you'll want to leave it at.  You would make a recommendation only if there is a clear and unanimous reason to - e.g. a particular setting will simply hang the machine, or a particular setting is almost universally the best one, etc.  This recommendation may (but may not) be conveyed to end users - it is left up to the end developers to use if they choose. -->

<!ELEMENT on (#PCDATA)*> <!-- Special setting indicating which setting has the semantic meaning of 'on'.  This mostly applies to boolean (i.e. switch or status) fields, though it may be defined for any.  The purpose is to disambiguate boolean fields which could potentially be active high or active low.  If this is defined for a single-bit-wide field, then the alternative setting is automatically taken as 'off' and need not have its own 'off' tag.  For fields which are multiple bits wide, no assumptions as such are made. -->
<!ATTLIST on
	name CDATA #IMPLIED
	value CDATA #REQUIRED
	mnemonic CDATA #IMPLIED
	recommended (%BooleanNames;) #IMPLIED> <!-- Same attributes as the 'setting' field, but with slightly different semantics - if no 'name' is provided it will be chosen automatically as necessary.  The expectation is typically that the 'on' or 'off' state will be implied via a checkbox or other such graphical indicator, so the name is of less importance than for other types of settings. -->

<!ELEMENT off (#PCDATA)*> <!-- Special setting indicating which setting has the semantic meaning of 'off'.  This mostly applies to boolean (i.e. switch or status) fields, though it may be defined for any.  The purpose is to disambiguate boolean fields which could potentially be active high or active low.  If this is defined for a single-bit-wide field, then the alternative setting is automatically taken as 'on' and need not have its own 'on' tag.  For fields which are multiple bits wide, no assumptions as such are made. -->
<!ATTLIST off
	name CDATA #IMPLIED
	value CDATA #REQUIRED
	mnemonic CDATA #IMPLIED
	recommended (%BooleanNames;) #IMPLIED> <!-- Same attributes as the 'setting' field, but with slightly different semantics - if no 'name' is provided it will be chosen automatically as necessary.  The expectation is typically that the 'on' or 'off' state will be implied via a checkbox or other such graphical indicator, so the name is of less importance than for other types of settings. -->


<!-- PMCs -->
<!ELEMENT pmc (summary?, description?, (pmcfield | property)*)>
<!ATTLIST pmc
	xmlns:match CDATA "urn:CoreProfile:deviceMatching"
	name CDATA #IMPLIED>

<!ELEMENT pmcfield (summary?, description?, (settings | bit | setting | on | off)*)> <!-- pmcfield is a logical subclass of the standard 'field', with the additional attributes 'index' and 'basedOn', and 'bitWidth' instead of 'bits' - the 'bits' attribute is not valid for pmcfields.  See the documentation for the 'field' element for information on all other attributes.  If a pmcfield is basedOn a register field, any subelements will override any existing, conflicting subelements from the register field.  i.e. if the pmcfield specifies a 'summary', that will replace the summary (if any) specified for the original register field. -->
<!ATTLIST pmcfield
	index CDATA #REQUIRED
	bitWidth CDATA #REQUIRED
	basedOn CDATA #IMPLIED
	name CDATA #IMPLIED
	mnemonic CDATA #IMPLIED
	type (reserved | bitfield | switch | status | enum | number) #IMPLIED
	base CDATA #IMPLIED
	signed (%BooleanNames;) #IMPLIED
	access CDATA #IMPLIED
	defaultValue CDATA #IMPLIED
	displayFunction CDATA #IMPLIED
	units CDATA #IMPLIED
	endianness (big | little | host) #IMPLIED> <!-- 'index' is the field index defined by the kext.
	
		'bitWidth' is the width of the field, in bits.
		
		'basedOn' indicates which register field this PMC field is based on; it has the form "<register mnemonic>[<field mnemonic>]", e.g. "MMCR0[HV]".  Any attributes specified on the pmcfield will override those specified on the base register field, with the exception of 'bitWidth' - it must match the base field's bit width as implied by its 'bits' attribute.  e.g. if the base register field has 'bits="4:7"' then bitWidth, if specified at all, must equal 4. -->

<!ELEMENT property (summary?, description?, setting*)>
<!ATTLIST property
	name CDATA #REQUIRED
	field CDATA #REQUIRED
	type (reserved | bitfield | switch | status | enum | number) #IMPLIED>


<!-- Events -->
<!ELEMENT event (summary?, description?)>
<!ATTLIST event
	type CDATA #REQUIRED> <!-- Defined types currently are 'KDebug' and 'PMC'. -->



<!-- The rest of this is just the XHTML DTD, really.  No need to go dig into this too much, if at all.  The only other thing of interest really are the 'description' and 'summary' tags right at the very end of this file, which integrate the XHTML. -->



<!-- XHTML -->

<!-- Based upon XHTML v1.0 (revision 1.1) from http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd.  Modified for use by CoreProfile such that 'description' elements (among others, potentially) can contain XHTML. -->

<!--
   Extensible HTML version 1.0 Strict DTD

   This is the same as HTML 4 Strict except for
   changes due to the differences between XML and SGML.

   Namespace = http://www.w3.org/1999/xhtml

   For further information, see: http://www.w3.org/TR/xhtml1

   Copyright (c) 1998-2002 W3C (MIT, INRIA, Keio),
   All Rights Reserved. 

   This DTD module is identified by the PUBLIC and SYSTEM identifiers:

   PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"

   $Revision: 1.1 $
   $Date: 2002/08/01 13:56:03 $

-->

<!--================ Character mnemonic entities =========================-->

<!ENTITY % HTMLlat1 PUBLIC
   "-//W3C//ENTITIES Latin 1 for XHTML//EN"
   "file://%24%7BCORE_PROFILE_DEVICES_FOLDER%7D/xhtml-lat1.ent">
%HTMLlat1;

<!ENTITY % HTMLsymbol PUBLIC
   "-//W3C//ENTITIES Symbols for XHTML//EN"
   "file://%24%7BCORE_PROFILE_DEVICES_FOLDER%7D/xhtml-symbol.ent">
%HTMLsymbol;

<!ENTITY % HTMLspecial PUBLIC
   "-//W3C//ENTITIES Special for XHTML//EN"
   "file://%24%7BCORE_PROFILE_DEVICES_FOLDER%7D/xhtml-special.ent">
%HTMLspecial;

<!--================== Imported Names ====================================-->

<!ENTITY % ContentType "CDATA">
    <!-- media type, as per [RFC2045] -->

<!ENTITY % ContentTypes "CDATA">
    <!-- comma-separated list of media types, as per [RFC2045] -->

<!ENTITY % Charset "CDATA">
    <!-- a character encoding, as per [RFC2045] -->

<!ENTITY % Charsets "CDATA">
    <!-- a space separated list of character encodings, as per [RFC2045] -->

<!ENTITY % LanguageCode "NMTOKEN">
    <!-- a language code, as per [RFC3066] -->

<!ENTITY % Character "CDATA">
    <!-- a single character, as per section 2.2 of [XML] -->

<!ENTITY % Number "CDATA">
    <!-- one or more digits -->

<!ENTITY % LinkTypes "CDATA">
    <!-- space-separated list of link types -->

<!ENTITY % MediaDesc "CDATA">
    <!-- single or comma-separated list of media descriptors -->

<!ENTITY % URI "CDATA">
    <!-- a Uniform Resource Identifier, see [RFC2396] -->

<!ENTITY % UriList "CDATA">
    <!-- a space separated list of Uniform Resource Identifiers -->

<!ENTITY % Datetime "CDATA">
    <!-- date and time information. ISO date format -->

<!ENTITY % Script "CDATA">
    <!-- script expression -->

<!ENTITY % StyleSheet "CDATA">
    <!-- style sheet data -->

<!ENTITY % Text "CDATA">
    <!-- used for titles etc. -->

<!ENTITY % Length "CDATA">
    <!-- nn for pixels or nn% for percentage length -->

<!ENTITY % MultiLength "CDATA">
    <!-- pixel, percentage, or relative -->

<!ENTITY % Pixels "CDATA">
    <!-- integer representing length in pixels -->

<!-- these are used for image maps -->

<!ENTITY % Shape "(rect|circle|poly|default)">

<!ENTITY % Coords "CDATA">
    <!-- comma separated list of lengths -->

<!--=================== Generic Attributes ===============================-->

<!-- core attributes common to most elements
  id       document-wide unique id
  class    space separated list of classes
  style    associated style info
  title    advisory title/amplification
-->
<!ENTITY % coreattrs
 "id          ID             #IMPLIED
  class       CDATA          #IMPLIED
  style       %StyleSheet;   #IMPLIED
  title       %Text;         #IMPLIED"
  >

<!-- internationalization attributes
  lang        language code (backwards compatible)
  xml:lang    language code (as per XML 1.0 spec)
  dir         direction for weak/neutral text
-->
<!ENTITY % i18n
 "lang        %LanguageCode; #IMPLIED
  xml:lang    %LanguageCode; #IMPLIED
  dir         (ltr|rtl)      #IMPLIED"
  >

<!-- attributes for common UI events
  onclick     a pointer button was clicked
  ondblclick  a pointer button was double clicked
  onmousedown a pointer button was pressed down
  onmouseup   a pointer button was released
  onmousemove a pointer was moved onto the element
  onmouseout  a pointer was moved away from the element
  onkeypress  a key was pressed and released
  onkeydown   a key was pressed down
  onkeyup     a key was released
-->
<!ENTITY % events
 "onclick     %Script;       #IMPLIED
  ondblclick  %Script;       #IMPLIED
  onmousedown %Script;       #IMPLIED
  onmouseup   %Script;       #IMPLIED
  onmouseover %Script;       #IMPLIED
  onmousemove %Script;       #IMPLIED
  onmouseout  %Script;       #IMPLIED
  onkeypress  %Script;       #IMPLIED
  onkeydown   %Script;       #IMPLIED
  onkeyup     %Script;       #IMPLIED"
  >

<!-- attributes for elements that can get the focus
  accesskey   accessibility key character
  tabindex    position in tabbing order
  onfocus     the element got the focus
  onblur      the element lost the focus
-->
<!ENTITY % focus
 "accesskey   %Character;    #IMPLIED
  tabindex    %Number;       #IMPLIED
  onfocus     %Script;       #IMPLIED
  onblur      %Script;       #IMPLIED"
  >

<!ENTITY % attrs "%coreattrs; %i18n; %events;">

<!--=================== Text Elements ====================================-->

<!ENTITY % special.pre
   "br | span | bdo | map">


<!ENTITY % special
   "%special.pre; | object | img ">

<!ENTITY % fontstyle "tt | i | b | big | small ">

<!ENTITY % phrase "em | strong | dfn | code | q |
                   samp | kbd | var | cite | abbr | acronym | sub | sup ">

<!ENTITY % inline.forms "input | select | textarea | label | button">

<!-- these can occur at block or inline level -->
<!ENTITY % misc.inline "ins | del | script">

<!-- these can only occur at block level -->
<!ENTITY % misc "noscript | %misc.inline;">

<!ENTITY % inline "a | %special; | %fontstyle; | %phrase; | %inline.forms;">

<!-- %Inline; covers inline or "text-level" elements -->
<!ENTITY % Inline "(#PCDATA | %inline; | %misc.inline;)*">

<!--================== Block level elements ==============================-->

<!ENTITY % heading "h1|h2|h3|h4|h5|h6">
<!ENTITY % lists "ul | ol | dl">
<!ENTITY % blocktext "pre | hr | blockquote | address">

<!ENTITY % block
     "p | %heading; | div | %lists; | %blocktext; | fieldset | table">

<!ENTITY % Block "(%block; | form | %misc;)*">

<!-- %Flow; mixes block and inline and is used for list items etc. -->
<!ENTITY % Flow "(#PCDATA | %block; | form | %inline; | %misc;)*">

<!--================== Content models for exclusions =====================-->

<!-- a elements use %Inline; excluding a -->

<!ENTITY % a.content
   "(#PCDATA | %special; | %fontstyle; | %phrase; | %inline.forms; | %misc.inline;)*">

<!-- pre uses %Inline excluding big, small, sup or sup -->

<!ENTITY % pre.content
   "(#PCDATA | a | %fontstyle; | %phrase; | %special.pre; | %misc.inline;
      | %inline.forms;)*">

<!-- form uses %Block; excluding form -->

<!ENTITY % form.content "(%block; | %misc;)*">

<!-- button uses %Flow; but excludes a, form and form controls -->

<!ENTITY % button.content
   "(#PCDATA | p | %heading; | div | %lists; | %blocktext; |
    table | %special; | %fontstyle; | %phrase; | %misc;)*">

<!--================ Document Structure ==================================-->

<!-- the namespace URI designates the document profile -->

<!ELEMENT html (head, body)>
<!ATTLIST html
  %i18n;
  id          ID             #IMPLIED
  xmlns       %URI;          #FIXED 'http://www.w3.org/1999/xhtml'
  >

<!--================ Document Head =======================================-->

<!ENTITY % head.misc "(script|style|meta|link|object)*">

<!-- content model is %head.misc; combined with a single
     title and an optional base element in any order -->

<!ELEMENT head (%head.misc;,
     ((title, %head.misc;, (base, %head.misc;)?) |
      (base, %head.misc;, (title, %head.misc;))))>

<!ATTLIST head
  %i18n;
  id          ID             #IMPLIED
  profile     %URI;          #IMPLIED
  >

<!-- The title element is not considered part of the flow of text.
       It should be displayed, for example as the page header or
       window title. Exactly one title is required per document.
    -->
<!ELEMENT title (#PCDATA)>
<!ATTLIST title 
  %i18n;
  id          ID             #IMPLIED
  >

<!-- document base URI -->

<!ELEMENT base EMPTY>
<!ATTLIST base
  href        %URI;          #REQUIRED
  id          ID             #IMPLIED
  >

<!-- generic metainformation -->
<!ELEMENT meta EMPTY>
<!ATTLIST meta
  %i18n;
  id          ID             #IMPLIED
  http-equiv  CDATA          #IMPLIED
  name        CDATA          #IMPLIED
  content     CDATA          #REQUIRED
  scheme      CDATA          #IMPLIED
  >

<!--
  Relationship values can be used in principle:

   a) for document specific toolbars/menus when used
      with the link element in document head e.g.
        start, contents, previous, next, index, end, help
   b) to link to a separate style sheet (rel="stylesheet")
   c) to make a link to a script (rel="script")
   d) by stylesheets to control how collections of
      html nodes are rendered into printed documents
   e) to make a link to a printable version of this document
      e.g. a PostScript or PDF version (rel="alternate" media="print")
-->

<!ELEMENT link EMPTY>
<!ATTLIST link
  %attrs;
  charset     %Charset;      #IMPLIED
  href        %URI;          #IMPLIED
  hreflang    %LanguageCode; #IMPLIED
  type        %ContentType;  #IMPLIED
  rel         %LinkTypes;    #IMPLIED
  rev         %LinkTypes;    #IMPLIED
  media       %MediaDesc;    #IMPLIED
  >

<!-- style info, which may include CDATA sections -->
<!ELEMENT style (#PCDATA)>
<!ATTLIST style
  %i18n;
  id          ID             #IMPLIED
  type        %ContentType;  #REQUIRED
  media       %MediaDesc;    #IMPLIED
  title       %Text;         #IMPLIED
  xml:space   (preserve)     #FIXED 'preserve'
  >

<!-- script statements, which may include CDATA sections -->
<!ELEMENT script (#PCDATA)>
<!ATTLIST script
  id          ID             #IMPLIED
  charset     %Charset;      #IMPLIED
  type        %ContentType;  #REQUIRED
  src         %URI;          #IMPLIED
  defer       (defer)        #IMPLIED
  xml:space   (preserve)     #FIXED 'preserve'
  >

<!-- alternate content container for non script-based rendering -->

<!ELEMENT noscript %Block;>
<!ATTLIST noscript
  %attrs;
  >

<!--=================== Document Body ====================================-->

<!ELEMENT body %Block;>
<!ATTLIST body
  %attrs;
  onload          %Script;   #IMPLIED
  onunload        %Script;   #IMPLIED
  >

<!ELEMENT div %Flow;>  <!-- generic language/style container -->
<!ATTLIST div
  %attrs;
  >

<!--=================== Paragraphs =======================================-->

<!ELEMENT p %Inline;>
<!ATTLIST p
  %attrs;
  >

<!--=================== Headings =========================================-->

<!--
  There are six levels of headings from h1 (the most important)
  to h6 (the least important).
-->

<!ELEMENT h1  %Inline;>
<!ATTLIST h1
   %attrs;
   >

<!ELEMENT h2 %Inline;>
<!ATTLIST h2
   %attrs;
   >

<!ELEMENT h3 %Inline;>
<!ATTLIST h3
   %attrs;
   >

<!ELEMENT h4 %Inline;>
<!ATTLIST h4
   %attrs;
   >

<!ELEMENT h5 %Inline;>
<!ATTLIST h5
   %attrs;
   >

<!ELEMENT h6 %Inline;>
<!ATTLIST h6
   %attrs;
   >

<!--=================== Lists ============================================-->

<!-- Unordered list -->

<!ELEMENT ul (li)+>
<!ATTLIST ul
  %attrs;
  >

<!-- Ordered (numbered) list -->

<!ELEMENT ol (li)+>
<!ATTLIST ol
  %attrs;
  >

<!-- list item -->

<!ELEMENT li %Flow;>
<!ATTLIST li
  %attrs;
  >

<!-- definition lists - dt for term, dd for its definition -->

<!ELEMENT dl (dt|dd)+>
<!ATTLIST dl
  %attrs;
  >

<!ELEMENT dt %Inline;>
<!ATTLIST dt
  %attrs;
  >

<!ELEMENT dd %Flow;>
<!ATTLIST dd
  %attrs;
  >

<!--=================== Address ==========================================-->

<!-- information on author -->

<!ELEMENT address %Inline;>
<!ATTLIST address
  %attrs;
  >

<!--=================== Horizontal Rule ==================================-->

<!ELEMENT hr EMPTY>
<!ATTLIST hr
  %attrs;
  >

<!--=================== Preformatted Text ================================-->

<!-- content is %Inline; excluding "img|object|big|small|sub|sup" -->

<!ELEMENT pre %pre.content;>
<!ATTLIST pre
  %attrs;
  xml:space (preserve) #FIXED 'preserve'
  >

<!--=================== Block-like Quotes ================================-->

<!ELEMENT blockquote %Block;>
<!ATTLIST blockquote
  %attrs;
  cite        %URI;          #IMPLIED
  >

<!--=================== Inserted/Deleted Text ============================-->

<!--
  ins/del are allowed in block and inline content, but its
  inappropriate to include block content within an ins element
  occurring in inline content.
-->
<!ELEMENT ins %Flow;>
<!ATTLIST ins
  %attrs;
  cite        %URI;          #IMPLIED
  datetime    %Datetime;     #IMPLIED
  >

<!ELEMENT del %Flow;>
<!ATTLIST del
  %attrs;
  cite        %URI;          #IMPLIED
  datetime    %Datetime;     #IMPLIED
  >

<!--================== The Anchor Element ================================-->

<!-- content is %Inline; except that anchors shouldn't be nested -->

<!ELEMENT a %a.content;>
<!ATTLIST a
  %attrs;
  %focus;
  charset     %Charset;      #IMPLIED
  type        %ContentType;  #IMPLIED
  name        NMTOKEN        #IMPLIED
  href        %URI;          #IMPLIED
  hreflang    %LanguageCode; #IMPLIED
  rel         %LinkTypes;    #IMPLIED
  rev         %LinkTypes;    #IMPLIED
  shape       %Shape;        "rect"
  coords      %Coords;       #IMPLIED
  >

<!--===================== Inline Elements ================================-->

<!ELEMENT span %Inline;> <!-- generic language/style container -->
<!ATTLIST span
  %attrs;
  >

<!ELEMENT bdo %Inline;>  <!-- I18N BiDi over-ride -->
<!ATTLIST bdo
  %coreattrs;
  %events;
  lang        %LanguageCode; #IMPLIED
  xml:lang    %LanguageCode; #IMPLIED
  dir         (ltr|rtl)      #REQUIRED
  >

<!ELEMENT br EMPTY>   <!-- forced line break -->
<!ATTLIST br
  %coreattrs;
  >

<!ELEMENT em %Inline;>   <!-- emphasis -->
<!ATTLIST em %attrs;>

<!ELEMENT strong %Inline;>   <!-- strong emphasis -->
<!ATTLIST strong %attrs;>

<!ELEMENT dfn %Inline;>   <!-- definitional -->
<!ATTLIST dfn %attrs;>

<!ELEMENT code %Inline;>   <!-- program code -->
<!ATTLIST code %attrs;>

<!ELEMENT samp %Inline;>   <!-- sample -->
<!ATTLIST samp %attrs;>

<!ELEMENT kbd %Inline;>  <!-- something user would type -->
<!ATTLIST kbd %attrs;>

<!ELEMENT var %Inline;>   <!-- variable -->
<!ATTLIST var %attrs;>

<!ELEMENT cite %Inline;>   <!-- citation -->
<!ATTLIST cite %attrs;>

<!ELEMENT abbr %Inline;>   <!-- abbreviation -->
<!ATTLIST abbr %attrs;>

<!ELEMENT acronym %Inline;>   <!-- acronym -->
<!ATTLIST acronym %attrs;>

<!ELEMENT q %Inline;>   <!-- inlined quote -->
<!ATTLIST q
  %attrs;
  cite        %URI;          #IMPLIED
  >

<!ELEMENT sub %Inline;> <!-- subscript -->
<!ATTLIST sub %attrs;>

<!ELEMENT sup %Inline;> <!-- superscript -->
<!ATTLIST sup %attrs;>

<!ELEMENT tt %Inline;>   <!-- fixed pitch font -->
<!ATTLIST tt %attrs;>

<!ELEMENT i %Inline;>   <!-- italic font -->
<!ATTLIST i %attrs;>

<!ELEMENT b %Inline;>   <!-- bold font -->
<!ATTLIST b %attrs;>

<!ELEMENT big %Inline;>   <!-- bigger font -->
<!ATTLIST big %attrs;>

<!ELEMENT small %Inline;>   <!-- smaller font -->
<!ATTLIST small %attrs;>

<!--==================== Object ======================================-->
<!--
  object is used to embed objects as part of HTML pages.
  param elements should precede other content. Parameters
  can also be expressed as attribute/value pairs on the
  object element itself when brevity is desired.
-->

<!ELEMENT object (#PCDATA | param | %block; | form | %inline; | %misc;)*>
<!ATTLIST object
  %attrs;
  declare     (declare)      #IMPLIED
  classid     %URI;          #IMPLIED
  codebase    %URI;          #IMPLIED
  data        %URI;          #IMPLIED
  type        %ContentType;  #IMPLIED
  codetype    %ContentType;  #IMPLIED
  archive     %UriList;      #IMPLIED
  standby     %Text;         #IMPLIED
  height      %Length;       #IMPLIED
  width       %Length;       #IMPLIED
  usemap      %URI;          #IMPLIED
  name        NMTOKEN        #IMPLIED
  tabindex    %Number;       #IMPLIED
  >

<!--
  param is used to supply a named property value.
  In XML it would seem natural to follow RDF and support an
  abbreviated syntax where the param elements are replaced
  by attribute value pairs on the object start tag.
-->
<!ELEMENT param EMPTY>
<!ATTLIST param
  id          ID             #IMPLIED
  name        CDATA          #IMPLIED
  value       CDATA          #IMPLIED
  valuetype   (data|ref|object) "data"
  type        %ContentType;  #IMPLIED
  >

<!--=================== Images ===========================================-->

<!--
   To avoid accessibility problems for people who aren't
   able to see the image, you should provide a text
   description using the alt and longdesc attributes.
   In addition, avoid the use of server-side image maps.
   Note that in this DTD there is no name attribute. That
   is only available in the transitional and frameset DTD.
-->

<!ELEMENT img EMPTY>
<!ATTLIST img
  %attrs;
  src         %URI;          #REQUIRED
  alt         %Text;         #REQUIRED
  longdesc    %URI;          #IMPLIED
  height      %Length;       #IMPLIED
  width       %Length;       #IMPLIED
  usemap      %URI;          #IMPLIED
  ismap       (ismap)        #IMPLIED
  >

<!-- usemap points to a map element which may be in this document
  or an external document, although the latter is not widely supported -->

<!--================== Client-side image maps ============================-->

<!-- These can be placed in the same document or grouped in a
     separate document although this isn't yet widely supported -->

<!ELEMENT map ((%block; | form | %misc;)+ | area+)>
<!ATTLIST map
  %i18n;
  %events;
  id          ID             #REQUIRED
  class       CDATA          #IMPLIED
  style       %StyleSheet;   #IMPLIED
  title       %Text;         #IMPLIED
  name        NMTOKEN        #IMPLIED
  >

<!ELEMENT area EMPTY>
<!ATTLIST area
  %attrs;
  %focus;
  shape       %Shape;        "rect"
  coords      %Coords;       #IMPLIED
  href        %URI;          #IMPLIED
  nohref      (nohref)       #IMPLIED
  alt         %Text;         #REQUIRED
  >

<!--================ Forms ===============================================-->
<!ELEMENT form %form.content;>   <!-- forms shouldn't be nested -->

<!ATTLIST form
  %attrs;
  action      %URI;          #REQUIRED
  method      (get|post)     "get"
  enctype     %ContentType;  "application/x-www-form-urlencoded"
  onsubmit    %Script;       #IMPLIED
  onreset     %Script;       #IMPLIED
  accept      %ContentTypes; #IMPLIED
  accept-charset %Charsets;  #IMPLIED
  >

<!--
  Each label must not contain more than ONE field
  Label elements shouldn't be nested.
-->
<!ELEMENT label %Inline;>
<!ATTLIST label
  %attrs;
  for         IDREF          #IMPLIED
  accesskey   %Character;    #IMPLIED
  onfocus     %Script;       #IMPLIED
  onblur      %Script;       #IMPLIED
  >

<!ENTITY % InputType
  "(text | password | checkbox |
    radio | submit | reset |
    file | hidden | image | button)"
   >

<!-- the name attribute is required for all but submit & reset -->

<!ELEMENT input EMPTY>     <!-- form control -->
<!ATTLIST input
  %attrs;
  %focus;
  type        %InputType;    "text"
  name        CDATA          #IMPLIED
  value       CDATA          #IMPLIED
  checked     (checked)      #IMPLIED
  disabled    (disabled)     #IMPLIED
  readonly    (readonly)     #IMPLIED
  size        CDATA          #IMPLIED
  maxlength   %Number;       #IMPLIED
  src         %URI;          #IMPLIED
  alt         CDATA          #IMPLIED
  usemap      %URI;          #IMPLIED
  onselect    %Script;       #IMPLIED
  onchange    %Script;       #IMPLIED
  accept      %ContentTypes; #IMPLIED
  >

<!ELEMENT select (optgroup|option)+>  <!-- option selector -->
<!ATTLIST select
  %attrs;
  name        CDATA          #IMPLIED
  size        %Number;       #IMPLIED
  multiple    (multiple)     #IMPLIED
  disabled    (disabled)     #IMPLIED
  tabindex    %Number;       #IMPLIED
  onfocus     %Script;       #IMPLIED
  onblur      %Script;       #IMPLIED
  onchange    %Script;       #IMPLIED
  >

<!ELEMENT optgroup (option)+>   <!-- option group -->
<!ATTLIST optgroup
  %attrs;
  disabled    (disabled)     #IMPLIED
  label       %Text;         #REQUIRED
  >

<!ELEMENT option (#PCDATA)>     <!-- selectable choice -->
<!ATTLIST option
  %attrs;
  selected    (selected)     #IMPLIED
  disabled    (disabled)     #IMPLIED
  label       %Text;         #IMPLIED
  value       CDATA          #IMPLIED
  >

<!ELEMENT textarea (#PCDATA)>     <!-- multi-line text field -->
<!ATTLIST textarea
  %attrs;
  %focus;
  name        CDATA          #IMPLIED
  rows        %Number;       #REQUIRED
  cols        %Number;       #REQUIRED
  disabled    (disabled)     #IMPLIED
  readonly    (readonly)     #IMPLIED
  onselect    %Script;       #IMPLIED
  onchange    %Script;       #IMPLIED
  >

<!--
  The fieldset element is used to group form fields.
  Only one legend element should occur in the content
  and if present should only be preceded by whitespace.
-->
<!ELEMENT fieldset (#PCDATA | legend | %block; | form | %inline; | %misc;)*>
<!ATTLIST fieldset
  %attrs;
  >

<!ELEMENT legend %Inline;>     <!-- fieldset label -->
<!ATTLIST legend
  %attrs;
  accesskey   %Character;    #IMPLIED
  >

<!--
 Content is %Flow; excluding a, form and form controls
--> 
<!ELEMENT button %button.content;>  <!-- push button -->
<!ATTLIST button
  %attrs;
  %focus;
  name        CDATA          #IMPLIED
  value       CDATA          #IMPLIED
  type        (button|submit|reset) "submit"
  disabled    (disabled)     #IMPLIED
  >

<!--======================= Tables =======================================-->

<!-- Derived from IETF HTML table standard, see [RFC1942] -->

<!--
 The border attribute sets the thickness of the frame around the
 table. The default units are screen pixels.

 The frame attribute specifies which parts of the frame around
 the table should be rendered. The values are not the same as
 CALS to avoid a name clash with the valign attribute.
-->
<!ENTITY % TFrame "(void|above|below|hsides|lhs|rhs|vsides|box|border)">

<!--
 The rules attribute defines which rules to draw between cells:

 If rules is absent then assume:
     "none" if border is absent or border="0" otherwise "all"
-->

<!ENTITY % TRules "(none | groups | rows | cols | all)">
  
<!-- horizontal alignment attributes for cell contents

  char        alignment char, e.g. char=':'
  charoff     offset for alignment char
-->
<!ENTITY % cellhalign
  "align      (left|center|right|justify|char) #IMPLIED
   char       %Character;    #IMPLIED
   charoff    %Length;       #IMPLIED"
  >

<!-- vertical alignment attributes for cell contents -->
<!ENTITY % cellvalign
  "valign     (top|middle|bottom|baseline) #IMPLIED"
  >

<!ELEMENT table
     (caption?, (col*|colgroup*), thead?, tfoot?, (tbody+|tr+))>
<!ELEMENT caption  %Inline;>
<!ELEMENT thead    (tr)+>
<!ELEMENT tfoot    (tr)+>
<!ELEMENT tbody    (tr)+>
<!ELEMENT colgroup (col)*>
<!ELEMENT col      EMPTY>
<!ELEMENT tr       (th|td)+>
<!ELEMENT th       %Flow;>
<!ELEMENT td       %Flow;>

<!ATTLIST table
  %attrs;
  summary     %Text;         #IMPLIED
  width       %Length;       #IMPLIED
  border      %Pixels;       #IMPLIED
  frame       %TFrame;       #IMPLIED
  rules       %TRules;       #IMPLIED
  cellspacing %Length;       #IMPLIED
  cellpadding %Length;       #IMPLIED
  >

<!ATTLIST caption
  %attrs;
  >

<!--
colgroup groups a set of col elements. It allows you to group
several semantically related columns together.
-->
<!ATTLIST colgroup
  %attrs;
  span        %Number;       "1"
  width       %MultiLength;  #IMPLIED
  %cellhalign;
  %cellvalign;
  >

<!--
 col elements define the alignment properties for cells in
 one or more columns.

 The width attribute specifies the width of the columns, e.g.

     width=64        width in screen pixels
     width=0.5*      relative width of 0.5

 The span attribute causes the attributes of one
 col element to apply to more than one column.
-->
<!ATTLIST col
  %attrs;
  span        %Number;       "1"
  width       %MultiLength;  #IMPLIED
  %cellhalign;
  %cellvalign;
  >

<!--
    Use thead to duplicate headers when breaking table
    across page boundaries, or for static headers when
    tbody sections are rendered in scrolling panel.

    Use tfoot to duplicate footers when breaking table
    across page boundaries, or for static footers when
    tbody sections are rendered in scrolling panel.

    Use multiple tbody sections when rules are needed
    between groups of table rows.
-->
<!ATTLIST thead
  %attrs;
  %cellhalign;
  %cellvalign;
  >

<!ATTLIST tfoot
  %attrs;
  %cellhalign;
  %cellvalign;
  >

<!ATTLIST tbody
  %attrs;
  %cellhalign;
  %cellvalign;
  >

<!ATTLIST tr
  %attrs;
  %cellhalign;
  %cellvalign;
  >


<!-- Scope is simpler than headers attribute for common tables -->
<!ENTITY % Scope "(row|col|rowgroup|colgroup)">

<!-- th is for headers, td for data and for cells acting as both -->

<!ATTLIST th
  %attrs;
  abbr        %Text;         #IMPLIED
  axis        CDATA          #IMPLIED
  headers     IDREFS         #IMPLIED
  scope       %Scope;        #IMPLIED
  rowspan     %Number;       "1"
  colspan     %Number;       "1"
  %cellhalign;
  %cellvalign;
  >

<!ATTLIST td
  %attrs;
  abbr        %Text;         #IMPLIED
  axis        CDATA          #IMPLIED
  headers     IDREFS         #IMPLIED
  scope       %Scope;        #IMPLIED
  rowspan     %Number;       "1"
  colspan     %Number;       "1"
  %cellhalign;
  %cellvalign;
  >


<!ENTITY % htmlContent "(#PCDATA | html | body | p | %heading; | div | %lists; | %blocktext; | fieldset | table | form | noscript | %misc.inline; | %inline;)*">


<!-- Misc -->
<!ELEMENT description %htmlContent;> <!-- A textual description of something.  May contain plaintext or XHTML.  Note that anywhere the 'description' tag may appear, multiple may appear if they indicate different content types.  So you can provide both plaintext and XHTML versions if you like.  This is often useful as while the framework will attempt to convert between the two as best it can to suite the requests of end developers, only relatively simple XHTML can be usefully converted, automatically, to plaintext.

	For XHTML content, there may be either a <html> element, a <body> element, a <p> element, or text interspersed with body-level tags.  The framework will automatically generate the higher-order tags as necessary. -->
<!ATTLIST description
	type (text | xhtml) #IMPLIED> <!-- Specifies explicitly the type of contents.  If not specified, the framework will make a best-effort guess as to what the content is. -->

<!ELEMENT summary %htmlContent;> <!-- A textual summary of something.  May contain plaintext or XHTML.  Note that anywhere the 'description' tag may appear, multiple may appear if they indicate different content types.  So you can provide both plaintext and XHTML versions if you like.  This is often useful as while the framework will attempt to convert between the two as best it can to suite the requests of end developers, only relatively simple XHTML can be usefully converted, automatically, to plaintext.

	For XHTML content, there may be either a <html> element, a <body> element, a <p> element, or text interspersed with body-level tags.  The framework will automatically generate the higher-order tags as necessary. -->
<!ATTLIST summary
	type (text | xhtml) #IMPLIED> <!-- Specifies explicitly the type of contents.  If not specified, the framework will make a best-effort guess as to what the content is. -->
